options {
    LOOKAHEAD=1;
    MULTI=true;
    JJTREE_OUTPUT_DIRECTORY="ast";
}
PARSER_BEGIN(Fac)
import java.io.FileReader;
import java.io.FileNotFoundException;

public class Fac {
    public int computeFac(SimpleNode node) {
        return 0;
    }

    public static void main(String[] args) throws ParseException {
        /** Validate arguments */
        if(args.length != 1) {
          System.out.println("Usage: " + args[0] + " <filename.jmm>");
          System.exit(1);
        }
        /** Open file */
        try {
            FileReader fileReader = new FileReader(args[0]);
            Fac fac = new Fac(fileReader);
            SimpleNode root = fac.Program();
    
            root.dump("");
    
            System.exit(0);
            
        } catch (FileNotFoundException e) {
            System.out.println("Failed to open file " + args[0]);
            System.exit(1);
        }
    }

    public static void showError(ParseException e, String errorMessage) {
        System.out.println(errorMessage);
    }
}
PARSER_END(Fac)

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  //System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
    System.out.println(t);
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}

SKIP :
{
    " " | "\r" | "\t" | "\n"
}
TOKEN:
{
    < MAIN : "main" > |
    < STATIC : "static" > |
    < VOID : "void" > |
    < PUBLIC : "public" > |
    < CLASS : "class" > |
    < STRING : "String" > |
    < IF : "if" > |
    < ELSE : "else" > |
    < WHILE : "while" > |
    < RETURN : "return" > |
    < INT : "int" > |
    < BOOLEAN : "boolean" > |
    < PVIRG : ";" > |
    < VIRG : "," > |
    < SUM : "+" > |
    < SUB : "-" > |
    < MULT : "*" > |
    < DIV : "/" > |
    < EQUAL : "=" > |
    < OPEN_CURLY_BRACKET : "{" > |
    < CLOSE_CURLY_BRACKET : "}" > |
    < OPEN_PARENTHESES : "(" > |
    < CLOSE_PARENTHESES : ")" > |
    < OPEN_BRACKET : "[" > |
    < CLOSE_BRACKET : "]" > |
    < NEW : "new" > |
    < THIS : "this" > |
    < TRUE : "true" > |
    < FALSE : "false" > |
    < LENGTH : "length" > |
    < EXTENDS : "extends" > |
    < NOT : "!" > |
    < AND : "&&" > |
    < LESS : "<" > |
    < GREATER : ">" > |
    < DOT : "." > |
    < INTEGERLITERAL : (["0"-"9"])+ > |
    < IDENTIFIER : ["a"-"z","A"-"Z","_","$"] (["a"-"z","A"-"Z","_","$","0"-"9"])* > 
}

SPECIAL_TOKEN : {
    <INLINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> |
    <BLOCK_COMMENT: "/*" (~["*", "/"])* "*" "/">
}

SimpleNode Program(): {}
{
    (ClassDeclaration())+ <EOF> 
    {
        return jjtThis;
    }
}

void ClassDeclaration() : {Token className, extendIdent;}
{
    <CLASS> className=<IDENTIFIER> 
    (<EXTENDS> extendIdent=<IDENTIFIER> {jjtThis.extendsClassName = extendIdent.image;})? 
    <OPEN_CURLY_BRACKET>
    (
        (VarDeclaration())* 
        (<PUBLIC> (MainDeclaration() | MethodDeclaration()))*
    )
    <CLOSE_CURLY_BRACKET>
    {jjtThis.className=className.image;}
}

void VarDeclaration() : {Token ident;}
{
	Type() ident=<IDENTIFIER> <PVIRG>
	{jjtThis.identifier = ident.image;}
}

void MainDeclaration() : {Token param;}
{
    <STATIC> <VOID> <MAIN> <OPEN_PARENTHESES> <STRING> <OPEN_BRACKET> <CLOSE_BRACKET> param=<IDENTIFIER> <CLOSE_PARENTHESES> <OPEN_CURLY_BRACKET>
    (
        MethodBody()
    )
    <CLOSE_CURLY_BRACKET>
    {jjtThis.param = param.image;}
}

void MethodDeclaration() : {Token ident;}
{
    Type() ident=<IDENTIFIER> 
    <OPEN_PARENTHESES> (MethodParameter() (<VIRG> MethodParameter())*)? <CLOSE_PARENTHESES> 
    <OPEN_CURLY_BRACKET> 
    (
        MethodBody()
        MethodReturn()
    )
    <CLOSE_CURLY_BRACKET>
    {jjtThis.identifier=ident.image;}
}

void MethodParameter() : {Token ident;}
{
    Type() ident=<IDENTIFIER> 
    {jjtThis.identifier=ident.image;}
}

void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
}

void MethodReturn() : {}
{
    <RETURN> Expression() <PVIRG>
}

void Type() : {Token type;}
{
    (type=<BOOLEAN> | 
    type=<INT> (<OPEN_BRACKET> <CLOSE_BRACKET> {jjtThis.isArray=true;})? | 
    type=<IDENTIFIER>)
    {jjtThis.dataType = type.image;}
}

void Statement() #void : {Token t;}
{
    <OPEN_CURLY_BRACKET> (Statement())* <CLOSE_CURLY_BRACKET> |
    If() |
    While() |
    Expression()
    (
        <PVIRG> |
        t=<EQUAL> Expression() <PVIRG> #Equal(2) //{jjtThis.str = t.image;}
    )
}

void If() : {}
{
    try {
        IfCondition() IfBody() ElseBody()
        //<IF> <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES> Statement() <ELSE> Statement()
    }
    catch (ParseException e) {
        showError(e, "if error");
        System.exit(0);
    }
}

void IfCondition() : {}
{
    try {
        <IF> <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES>
    }
    catch (ParseException e) {
        showError(e, "if error");
        System.exit(0);
    }
}

void IfBody() : {}
{
    try {
        Statement()
    }
    catch (ParseException e) {
        showError(e, "if error");
        System.exit(0);
    }
}

void ElseBody() : {}
{
    try {
        <ELSE> Statement()
    }
    catch (ParseException e) {
        showError(e, "if error");
        System.exit(0);
    }
}

void While() : {}
{
    try {
        <WHILE> <OPEN_PARENTHESES> WhileCondition() <CLOSE_PARENTHESES> WhileBody() 
    }
    catch (ParseException e) {
        error_skipto(CLOSE_PARENTHESES);
        showError(e, "while error");
        //System.exit(0);
    }
}

void WhileCondition() : {}
{
	Expression()	
}

void WhileBody() : {} 
{
	Statement()	
}

void Expression() #void : {} 
{
    Expression1(1)
    (
        <AND> Expression() #And(2) |
        <OPEN_BRACKET> Expression() <CLOSE_BRACKET> |
        <DOT> 
        (
            <LENGTH> |
            <IDENTIFIER> <OPEN_PARENTHESES> (Expression() (<VIRG> Expression())*)? <CLOSE_PARENTHESES>
        )
    )?
}

void Expression1(int sign) #void : {} 
{
    Expression2(sign) (<LESS> Expression2(1) #Less(2))*
}

void Expression2(int sign) #void : {} 
{
    Expression3(sign) 
    [
        <SUM> Expression3(1) #Add(2) | 
        <SUB> Expression3(1) #Sub(2)
    ]
}

void Expression3(int sign) #void : {} 
{
    Term(sign) 
    [
        <MULT> Expression3(1) #Mult(2) | 
        <DIV> Expression3(1) #Div(2)
    ]
}

void Term(int sign) : {Token t;}
{
    t=<INTEGERLITERAL> {jjtThis.val = sign * Integer.parseInt(t.image);} |
    t=<TRUE> {jjtThis.str = t.image;}|
    t=<FALSE> {jjtThis.str = t.image;}|
    t=<IDENTIFIER> {jjtThis.str = t.image;}|
    t=<THIS> {jjtThis.str = t.image;}|
    <NEW>
    (
        <INT> <OPEN_BRACKET> Expression() <CLOSE_BRACKET> | 
        <IDENTIFIER> <OPEN_PARENTHESES> <CLOSE_PARENTHESES>
    ) |
    t=<NOT> Term(1) {jjtThis.str = t.image;}|
    <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES>
}

