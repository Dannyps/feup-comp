options {
    LOOKAHEAD=1;
    MULTI=true;
    ERROR_REPORTING=true;
}
PARSER_BEGIN(Fac)
import java.io.FileReader;
import java.io.FileNotFoundException;

public class Fac {

    public static void main(String[] args) throws ParseException {

        try {
            FileReader fileReader = new FileReader("text.txt");
            Fac fac = new Fac(fileReader);
            SimpleNode root = fac.Program();
    
            root.dump("");
    
            System.exit(0);
            
        } catch (FileNotFoundException e) {
            System.exit(0);
            //TODO: handle exception
        } catch (Exception e) {
            System.exit(1);
        }
    }

    public static void showError(ParseException e, String errorMessage) {
        System.out.println(errorMessage);
    }
}
PARSER_END(Fac)

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}

JAVACODE
void printError(Token t, String expected){
    System.out.println("[ERROR] text.txt:"+t.beginLine+":"+t.beginColumn+" Token `" +t+ "` was not recognized. Expected: `"+ expected +"`." );
}


SKIP :
{
    " " | "\r" | "\t" | "\n"
}
TOKEN:
{
    < MAIN : "main" > |
    < STATIC : "static" > |
    < VOID : "void" > |
    < PUBLIC : "public" > |
    < CLASS : "class" > |
    < STRING : "String" > |
    < IF : "if" > |
    < ELSE : "else" > |
    < WHILE : "while" > |
    < RETURN : "return" > |
    < INT : "int" > |
    < BOOLEAN : "boolean" > |
    < PVIRG : ";" > |
    < VIRG : "," > |
    < SUM : "+" > |
    < SUB : "-" > |
    < MULT : "*" > |
    < DIV : "/" > |
    < EQUAL : "=" > |
    < OPEN_CURLY_BRACKET : "{" > |
    < CLOSE_CURLY_BRACKET : "}" > |
    < OPEN_PARENTHESES : "(" > |
    < CLOSE_PARENTHESES : ")" > |
    < OPEN_BRACKET : "[" > |
    < CLOSE_BRACKET : "]" > |
    < NEW : "new" > |
    < THIS : "this" > |
    < TRUE : "true" > |
    < FALSE : "false" > |
    < LENGTH : "length" > |
    < EXTENDS : "extends" > |
    < NOT : "!" > |
    < AND : "&&" > |
    < LESS : "<" > |
    < GREATER : ">" > |
    < DOT : "." > |
    < INTEGERLITERAL : (["0"-"9"])+ > |
    < IDENTIFIER : ["a"-"z","A"-"Z","_","$"] (["a"-"z","A"-"Z","_","$","0"-"9"])* > 
}

SPECIAL_TOKEN : {
    <INLINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> |
    <BLOCK_COMMENT: "/*" (~["*", "/"])* "*" "/">
}

SimpleNode Program(): {}
{   
    try {
        ClassDeclaration() <EOF>
        {
            return jjtThis;
        }
    } catch (ParseException e) {
        System.out.println(e);
        System.out.println("An error ocurred while compiling the program. Please fix the errors above and try again.");
        throw e;
    }

}

void ClassDeclaration() : {Token className, extendIdent;}
{   
    try {
        <CLASS> className=<IDENTIFIER> 
        {jjtThis.className=className.image;}
    } catch (ParseException e) {
        printError(getToken(1), "class");
        throw e;
    }

    (<EXTENDS> extendIdent=<IDENTIFIER> {jjtThis.extendsClassName = extendIdent.image;})? 
    <OPEN_CURLY_BRACKET>
    (
        (VarDeclaration())* 
        (<PUBLIC> (MainDeclaration() | MethodDeclaration()))*
    )
    <CLOSE_CURLY_BRACKET>

}

void VarDeclaration() : {Token ident;}
{
	Type() ident=<IDENTIFIER> <PVIRG>
    // |
    // error_skipto(PVIRG)
	{jjtThis.identifier = ident.image;}
}

void MainDeclaration() : {Token param;}
{
    <STATIC> <VOID> <MAIN> <OPEN_PARENTHESES> <STRING> <OPEN_BRACKET> <CLOSE_BRACKET> param=<IDENTIFIER> <CLOSE_PARENTHESES> <OPEN_CURLY_BRACKET>
    (
        MethodBody()
    )
    <CLOSE_CURLY_BRACKET>
    {jjtThis.param = param.image;}
}

void MethodDeclaration() : {Token ident;}
{
    Type() ident=<IDENTIFIER> 
    <OPEN_PARENTHESES> (MethodParameter() (<VIRG> MethodParameter())*)? <CLOSE_PARENTHESES> 
    <OPEN_CURLY_BRACKET> 
    (
        MethodBody()
        MethodReturn()
    )
    <CLOSE_CURLY_BRACKET>
    {jjtThis.identifier=ident.image;}
}

void MethodParameter() : {Token ident;}
{
    Type() ident=<IDENTIFIER> 
    {jjtThis.identifier=ident.image;}
}

void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
}

void MethodReturn() : {}
{
    <RETURN> Expression() <PVIRG>
}

void Type() : {Token type;}
{
    (type=<BOOLEAN> | 
    type=<INT> (<OPEN_BRACKET> <CLOSE_BRACKET> {jjtThis.isArray=true;})? | 
    type=<IDENTIFIER>)
    {jjtThis.dataType = type.image;}
}

void Statement() : {}
{
    <OPEN_CURLY_BRACKET> (Statement())* <CLOSE_CURLY_BRACKET> |
    If() |
    While() |
    Expression()
    (
        <PVIRG> |
        <EQUAL> Expression() <PVIRG>
    )
}

void If() #void : {}
{
    try {
        <IF> <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES> Statement() <ELSE> Statement()
    }
    catch (ParseException e) {
        showError(e, "if error");
        System.exit(0);
    }
}

void While() : {}
{
    try {
        <WHILE> <OPEN_PARENTHESES> WhileCondition() <CLOSE_PARENTHESES> WhileBody() 
    }
    catch (ParseException e) {
        showError(e, "while error");
        System.exit(0);
    }
}

void WhileCondition() : {}
{
	Expression()	
}

void WhileBody() : {} 
{
	Statement()	
}

void Term() #void : {}
{
    <INTEGERLITERAL> |
    <TRUE> |
    <FALSE> |
    <IDENTIFIER> |
    <THIS> |
    <NEW>
    (
        <INT> <OPEN_BRACKET> Expression() <CLOSE_BRACKET> | 
        <IDENTIFIER> <OPEN_PARENTHESES> <CLOSE_PARENTHESES>
    ) |
    <NOT> Term() |
    <OPEN_PARENTHESES> Expression() <CLOSE_PARENTHESES>
}

void Expression() : {} 
{
    Expression1()
    (
        <AND> Expression() |
        <OPEN_BRACKET> Expression() <CLOSE_BRACKET> |
        <DOT> 
        (
            <LENGTH> |
            <IDENTIFIER> <OPEN_PARENTHESES> (Expression() (<VIRG> Expression())*)? <CLOSE_PARENTHESES>
        )
    )?
}

void Expression1() #void : {} 
{
    Expression2() (<LESS> Expression2())*
}

void Expression2() #void : {} 
{
    Expression3() ((<SUM> | <SUB>) Expression3())*
}

void Expression3() #void : {} 
{
    Term() ((<MULT> | <DIV>) Term())*
}
